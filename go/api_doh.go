/*
 * Swagger DoH
 *
 * This is a DNS-over-HTTP (DoH) resolver written in Go.
 *
 * API version: 0.1
 * Contact: dev@phunsites.net
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
)

// indices of DNS request header
const DNS_HDR_RQ_ID = 0
const DNS_HDR_RQ_FLAGS = 1
const DNS_HDR_RQ_QDCOUNT = 2
const DNS_HDR_RQ_ANCOUNT = 3
const DNS_HDR_RQ_NSCOUNT = 4
const DNS_HDR_RQ_ARCOUNT = 5

// indices of DNS request flags
const DNS_FLAGS_TYPE_QUERY = 0
const DNS_FLAGS_TYPE_RESPONSE = 1

/*
 * sendError()
 *
 * helper to send error message to the client
 *
 */
func sendError(w http.ResponseWriter, httpStatusCode int, errorMessage string) {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(httpStatusCode)
	fmt.Fprintf(w, errorMessage)
	log.Printf(errorMessage)

	return
}

/*
 * ParseDnsHeader()
 *
 * parses and returns the request/response Header from the DNS payload
 *
 */
func ParseDnsHeader(reqData []byte) [6]uint16 {
	// first word is the request ID
	var _reqId = []byte{reqData[0], reqData[1]}
	reqId := binary.BigEndian.Uint16(_reqId)

	// second word is the request flags
	//
	var _reqFlags = []byte{reqData[2], reqData[3]}
	reqFlags := binary.BigEndian.Uint16(_reqFlags)

	// third word is the Question Count
	//
	var _reqQdCount = []byte{reqData[4], reqData[5]}
	reqQdCount := binary.BigEndian.Uint16(_reqQdCount)

	// forth word is the Answer Count
	//
	var _reqAnCount = []byte{reqData[6], reqData[7]}
	reqAnCount := binary.BigEndian.Uint16(_reqAnCount)

	// fifth word is the NS Count
	//
	var _reqNsCount = []byte{reqData[8], reqData[9]}
	reqNsCount := binary.BigEndian.Uint16(_reqNsCount)

	// sixth word is the AR Count
	//
	var _reqArCount = []byte{reqData[10], reqData[11]}
	reqArCount := binary.BigEndian.Uint16(_reqArCount)

	return [6]uint16{reqId, reqFlags, reqQdCount, reqAnCount, reqNsCount, reqArCount}
}

/*
 * NOT IMPLEMENTED YET
 */
func ParseDnsQuestion(reqData []byte) []byte {
	return nil
}

/*
 * NOT IMPLEMENTED YET
 */
func validateReqFlags(reqFlags uint16) bool {
	return true
}

/*
 * sendDnsRequest()
 *
 * send a DNS request to the resolver and return it's response
 */
func sendDnsRequest(dnsRequestData []byte) ([]byte, error) {

	// open UDP connection to DNS resolver
	// FIXME IP should come from ENV
	udpConn, udpConnErr := net.Dial("udp", "192.168.100.201:53")
	defer udpConn.Close()

	if udpConnErr != nil {
		return nil, udpConnErr
	}

	// send DNS request to resolver
	udpConn.Write(dnsRequestData)

	// traditional DNS is limited to 512 bytes,
	// while EDNS supports up to 2K. We'll go with a 2K buffer
	//
	// this may need fixing. we should not read a fixed buffer,
	// but meabe read-until-EOF, although single-buffer read is
	// most likely faster
	dnsResponseDataRaw := make([]byte, 2048)
	dnsResponseLength, dnsResponseErr := bufio.NewReader(udpConn).Read(dnsResponseDataRaw)

	if dnsResponseErr != nil {
		return nil, dnsResponseErr
	}

	// !!! NOTE !!!
	// this needs fixing:
	//
	// because of our fixed-size buffer allocation, response is a zero-padded slice.
	// the code below initializes a new slice with the real payload length received,
	// and copies the RAW slice over. All excess bytes will overflow and be truncated.
	dnsResponseData := make([]byte, dnsResponseLength)
	copy(dnsResponseData, dnsResponseDataRaw)

	return dnsResponseData, nil
}

/*
 * CommonDnsRequestHandler()
 *
 * shared routine for DNS Requests passed in by either GET or POST
 */
func CommonDnsRequestHandler(w http.ResponseWriter, r http.Request, dnsRequest []byte) {
	var ccNoCache bool = false // default for Cache-Control: NoCache is FALSE (means: reply from cache)
	var ccNoStore bool = false // default for Cache-Control: NoStore is FALSE (means: store to cache)
	_ = ccNoCache              // FIXME: backend code for ccNoCache not there yet. Silence compiler warning using this directive

	// bail out if DNS request is smaller than 28 bytes
	if len(dnsRequest) < 28 {
		sendError(w, http.StatusBadRequest, "Malformed request: DNS payload is below treshold")
		return
	}

	// check Cache-Control request headers
	for _, value := range r.Header["Cache-Control"] {
		if value == "no-cache" {
			log.Println("Client requested Cache-Control: no-cache")
			ccNoCache = true // client instructed to not response from server-side cache
		}
		if value == "no-store" {
			log.Println("Client requested Cache-Control: no-store")
			ccNoStore = true // client instructed to not store to server-side cache
		}
	}

	// parse the DNS Header
	dnsHeader := ParseDnsHeader(dnsRequest)

	// FIXME
	// does not work yet (backend code is still missing)
	// validate request flags
	if !validateReqFlags(dnsHeader[DNS_HDR_RQ_FLAGS]) {
		sendError(w, http.StatusBadRequest, "Invalid DNS Flags observed in DNS request.")
		return
	}

	// FIXME: implement server-side cache, but honor ccNoCache
	dnsResponse, dnsResponseErr := sendDnsRequest(dnsRequest)
	if dnsResponseErr != nil {
		sendError(w, http.StatusBadRequest, fmt.Sprintf("Error during DNS resolution: %s", dnsResponseErr))
		return
	}
	// FIXME: implement server-side cache, but honor ccNoStore

	// parse DNS Question
	/*
		FIXME: not implemented yet in backend code
		dnsQuestion := ParseDnsQuestion(dnsResponse)
	*/

	// return dns-message to client
	w.Header().Set("Content-Type", "application/dns-message")

	// honor ccNoCache flag: set max-age:0 to indicate we did our best to not cache
	if ccNoStore == true {
		w.Header().Set("Cache-Control", "max-age: 0")
	} else {
		// FIXME: this should actually be the *lowest* TTL from the DNS response
		// we need a DNS response parser to handle this
		w.Header().Set("Cache-Control", "max-age: 15")
	}

	// conclude with OK status code and return the dns payload
	w.WriteHeader(http.StatusOK)
	w.Write(dnsResponse)
}

/*
 * DnsQueryGet()
 *
 * GET handler for DNS queries
 */
func DnsQueryGet(w http.ResponseWriter, r *http.Request) {
	// validate 'dns' attribute from GET request arguments
	argDns, queryParseSuccess := r.URL.Query()["dns"]
	if !queryParseSuccess || len(argDns[0]) < 1 || len(argDns) > 1 {
		// bail out if 'dns' is zero-length
		sendError(w, http.StatusBadRequest, "Mandatory 'dns' request parameter is either not set, empty, or defined multiple times")
		return
	}

	// decode the DNS request
	// NOTE: this uses RFC4648 URL encoding *without* padding
	dnsRequest, base64DecodeErr := base64.RawURLEncoding.DecodeString(argDns[0])
	if base64DecodeErr != nil {
		sendError(w, http.StatusBadRequest, fmt.Sprintf("Error decoding DNS request data from Base64: %s", base64DecodeErr))
		return
	}

	// pass DNS request to request handler
	CommonDnsRequestHandler(w, *r, dnsRequest)

	return
}

/*
 * DnsQueryGet()
 *
 * POST handler for DNS queries
 */
func DnsQueryPost(w http.ResponseWriter, r *http.Request) {
	// bail out on unsupported content-type
	if r.Header.Get("Content-Type") != "application/dns-message" {
		sendError(w, http.StatusUnsupportedMediaType, "unsupported or missing Content-Type")
		return
	}

	// some minimal sanity checking on the message body
	if r.Body == nil {
		sendError(w, http.StatusBadRequest, "Missing body payload")
		return
	}

	// get DNS request from message body
	dnsRequest, _ := ioutil.ReadAll(r.Body)
	r.Body = ioutil.NopCloser(bytes.NewBuffer(dnsRequest))

	// bail out if 'body' is zero-length
	if len(dnsRequest) == 0 {
		// bail out if 'body' is zero-length
		sendError(w, http.StatusBadRequest, "Missing dns message payload")
		return
	}

	// pass DNS request to request handler
	CommonDnsRequestHandler(w, *r, dnsRequest)

	return
}
